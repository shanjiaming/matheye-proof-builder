
  太好了！从DeepWiki的回答可以看出，Lean 4有专门的函数来格式化整个AST节点：
  - ppTactic (stx : TSyntax tactic) : CoreM Format` 
  - ppCommand (stx : Syntax.Command) : CoreM Format

  现在的实现确实很奇怪，不应该手动拼接每个tactic的格式化结果。应该直接用ppTactic或者ppCategory来格式化整个tactic序列。

  对于第二个问题（scope识别），让我想想更好的方案。硬编码检测=>确实很脆弱。更好的方法应该是通过AST的语法信息来判断。

⏺ 1. 格式化输出的根本问题

  你说得对，现在的做法确实很奇怪！Lean有原生的格式化机制，不应该手动拼接。

  当前的错误做法

  let parts ← args.mapM (fun a => do
    let fmt ← PrettyPrinter.formatCategory `tactic a
    pure fmt.pretty)
  -- 手动加换行 - 这很奇怪！
  pure <| parts.foldl (fun acc p => if acc.isEmpty then p else acc ++ "\n" ++ p) ""

  正确的Lean方式

  根据Lean 4的PrettyPrinter文档，应该这样做：

  def formatTacticSeq (stx : Syntax) : MetaM String := do
    -- 直接格式化整个AST节点
    let fmt ← PrettyPrinter.ppCategory `tacticSeq stx
    return fmt.pretty

  -- 或者对于单个tactic：
  def formatWholeTactic (stx : TSyntax `tactic) : CoreM String := do
    let fmt ← PrettyPrinter.ppTactic stx
    return fmt.pretty

  优势：
  - Lean原生处理缩进、换行、空格
  - 自动处理复杂的语法结构
  - 保证输出符合Lean的格式化标准
  - 不需要手动处理edge cases

  2. Scope识别的根本问题

  硬编码检测=>确实太脆弱了！这种方法无法处理：
  - 嵌套的cases/match
  - 复杂的语法结构
  - 未来的语法扩展

  当前的脆弱做法

  const arrow = txt.indexOf('=>'); // 硬编码！
  if (arrow >= 0) {
      includeByOnSeq = false;
  } else {
      includeByOnSeq = true;
  }

  更智能的AST-based方法

  方案1: 使用InfoTree的语法上下文

  def detectTacticContext (pos : Lsp.Position) (snap : Snapshot) : RequestM TacticContext := do
    let results := snap.infoTree.goalsAt? text pos
    match results.head? with
    | some r =>
      let stx := r.tacticInfo.stx
      let kind := stx.getKind
      -- 通过AST的Kind来判断上下文
      if kind == `Lean.Parser.Tactic.tacticSeq1Indented then
        return TacticContext.ByBlock
      else if kind == `Lean.Parser.Command.match then
        return TacticContext.MatchBranch
      else if kind == `Lean.Parser.Tactic.cases then
        return TacticContext.CasesBranch
      -- ... 更多语法结构

  方案2: 通过AST层级关系判断

  def findTacticContainer (stx : Syntax) : Option ContainerType := do
    -- 向上遍历AST找到最近的容器
    let parent := stx.getParent?
    match parent with
    | some (.node _ kind _) =>
      if kind.toString.contains "match" then return some ContainerType.Match
      if kind.toString.contains "cases" then return some ContainerType.Cases
      if kind.toString.contains "by" then return some ContainerType.By
      -- 递归向上查找
      return findTacticContainer parent
    | _ => return none

  方案3: 使用Lean的Elaborator上下文

  def getElaborationContext (pos : Lsp.Position) : RequestM ElabContext := do
    withWaitFindSnapAtPos pos fun snap => do
      let results := snap.infoTree.goalsAt? text pos
      match results.head? with
      | some r =>
        -- 使用ctxInfo获取更丰富的上下文信息
        let tacticState := r.tacticInfo.goalsAfter
        let syntaxContext := r.tacticInfo.stx.getKind
        -- 基于elaboration上下文做决策
        return { tacticState, syntaxContext, ... }

  3. 建议的重构方案

  格式化部分重构

  -- 替换现有的formatTacticSeq
  def formatTacticSeqProper (stx : Syntax) : MetaM String := do
    match stx with
    | .node _ kind args =>
      -- 使用Lean原生格式化
      let fmt ← PrettyPrinter.ppCategory (kindToCategory kind) stx
      return fmt.pretty
    | _ =>
      let fmt ← PrettyPrinter.ppCategory `tactic stx
      return fmt.pretty

  -- 辅助函数：从Kind映射到Category
  def kindToCategory (kind : Name) : Name :=
    if kind == `Lean.Parser.Tactic.tacticSeq1Indented then `tacticSeq
    else if kind == `Lean.Parser.Tactic.tacticSeqBracketed then `tacticSeq
    else `tactic

  Scope识别重构

  structure TacticInsertionContext where
    containerType : ContainerType
    needsByKeyword : Bool
    indentLevel : Nat
    insertionStrategy : InsertionStrategy

  def analyzeTacticContext (pos : Lsp.Position) (snap : Snapshot) : RequestM TacticInsertionContext := do
    let results := snap.infoTree.goalsAt? text pos
    match results.head? with
    | some r =>
      let containerAnalysis ← analyzeContainerHierarchy r.tacticInfo.stx
      let indentAnalysis ← calculateProperIndentation pos
      return {
        containerType := containerAnalysis.type,
        needsByKeyword := containerAnalysis.needsBy,
        indentLevel := indentAnalysis.level,
        insertionStrategy := determineStrategy containerAnalysis
      }

  4. 为什么这样更好？

  格式化方面：

  - 正确性：使用Lean原生formatter确保语法正确
  - 一致性：输出格式与Lean标准一致
  - 维护性：不需要手动处理各种edge cases
  - 扩展性：自动支持新的语法结构

  Scope识别方面：

  - 鲁棒性：基于AST结构，不依赖文本模式匹配
  - 完整性：能处理所有Lean语法结构
  - 扩展性：新增语法结构时只需添加新的pattern
  - 准确性：利用Lean的type information做判断

  这种重构会让系统更加robust，也更符合Lean的设计哲学。你觉得这个方向如何？









  ----------------------------





  明白，开始动手按定下的方案重构。我先做了“可落地的第一阶段”，确保不破你的两条硬约束，并给后续“父亲链锚”回滚留好可演进
接口。

本轮已完成

- 统一容器选择（Lean 端）
    - 新增私有函数：chooseSmallestTacticSeq(stxs, fallback)。从当前位置的 AST 路径里选“最小的 tactic 序列容
器”（tacticSeq/tacticSeq1Indented/tacticSeqBracketed）。不做正则/启发式/文本扫描。
    - getByBlockRange：使用该函数，返回容器的 AST 范围、kind、上下文信息（isTacticContext/isTermContext/
parentKinds）。避免再返回叶子 token（如 exact）的窄范围。
    - insertHaveByAction：同样使用该函数，保证编辑目标与 getByBlockRange 一致，不再“时用入参、时用自判”。
    - insertHaveByAction：同样使用该函数，保证编辑目标与 getByBlockRange 一致，不再“时用入参、时用自判”。
- 
全文件替换支持（Lean 端 + VSCode 端）
    - Lean 端 insertHaveByAction 新增参数 returnWholeFile?（默认 false）。
    - 若 true：在服务器端将容器编辑后的片段拼回整篇文本，返回 { newText=整文件, range=整文件范围 }。
    - 若 false：返回 { newText=容器片段, range=容器范围 }（以兼容当前逻辑光标历史路径，还未切至锚回滚前，继续工作不
受阻）。
- VSCode 端调用：
    - 命令路径（Insert Have Admit/Deny）：传 returnWholeFile=true，客户端始终整文件替换，避免 VSCode/Lean 漂移。
    - 逻辑光标路径（带历史的 applyFeedbackWithLogicalCursor）：暂时 returnWholeFile=false，保留按块的局部范围回滚（下
轮会换成“锚+整文件”的回滚）。

- 保持测试开关与诊断
    - F5 启动默认 MATHEYE_TEST_MODE=1、MATHEYE_USE_REAL_RPC=1。
    - 逻辑光标路径保留简要诊断日志（byRange、insertPos、resp.range），仅 test mode 写入文件，正常运行无噪声。

为什么这样分两步

- 目标状态是“按块历史 + AST→整文件替换”。但历史的回滚目前仍是 range-based（原仓库已有），直接改会牵动现有测试与行为。
- 先把“编辑路径”统一到服务器 AST + 全文件替换（命令路径已切换，逻辑光标路径已具备全文件能力开关）；并把“容器选择”完全
统一，规避“exact 叶子窄替换”这类错误。
- 下一步引入“父亲链锚” capture/restore 两个 RPC，再将逻辑光标路径的回滚改为“按锚 + 整文件替换”，从而达成两条硬约束同时
满足：历史仍按块，文本落地始终整文件。

下一步（按你的审阅后开做）

    - declName：封闭声明名；path：从声明根到容器的“父亲链”（每层 kind + idx）；originalBodyPretty：容器操作前的 pretty
文本。
- restoreByAnchor({ declName, path, originalBody }) → { newText, range=整文件 } | { success=false, reason=Missing }
    - 在 declName 下按 path 逐层匹配容器节点（严格匹配 kind、idx）；任一步失败即 Missing（不做回退/模糊）；匹配到后用
originalBody 解析替换容器 AST，pretty-print 整篇文本返回。
- VSCode 端
    - 历史条目：改为 { declName, path, originalBody, uri, ts }（按块管理）；不再依赖 range 作为锚。
    - 正向编辑：调用 captureAnchor 存锚，然后 insertHaveByAction(returnWholeFile=true) 落地整文件。
    - 回滚：调用 restoreByAnchor 落地整文件；旧的基于 range 的回滚入口停用（不留 fallback）。
- 测试（real 模式）
    - admit/deny 在 by 块、match/cases 分支、·bullet 子块中行为正确，回滚恢复原状。
    - 祖先容器结构变化（插入/删除/重排）导致该子块回滚返回 Missing（明确拒绝，不猜测）。
    - 端到端编译验证（lake env lean）始终过。

说明与取舍

- “·” 子块（tactic bullets）同样是 tacticSeq* 容器，统一由 chooseSmallestTacticSeq 处理，无需特判。
- 我们先不引入任何“模糊重锚”，严格按父亲链 path 逐层匹配；结构变→ Missing（宁错杀，不误伤），符合“不要 fallback”的
要求。
- 命令路径已经切到全文件替换，逻辑光标路径在切锚回滚前继续使用局部范围回滚以保持行为稳定；一旦 restoreByAnchor 上线，
会把逻辑光标路径也切到全文件替换 + 按锚回滚，彻底去除局部文本拼接。

你过目这版细化计划，如果 OK，我按此继续实现 capture/restore 两个 RPC 和历史改造，然后把逻辑光标路径也切换为“按锚 + 整
文件替换”的最终形态。